# 研路相随后端—Spring Cloud Alibaba 微服务

## 一、分布式 ID 生成方案

> 项目中考虑高并发场景的笔记 ID 生成还有用户 ID 生成方案，两个场景的需求不同，故需考虑不同的分布式 ID 生成方案。目前考虑的有美团 Leaf-Segment 号段模式，Leaf-Snowflake 雪花算法，Redis INCR + AOF + MQ 缓存方式。

### 1、Leaf-Segment

#### **原理**

- 基于数据库预分配号段（批量获取ID范围），如每次从数据库加载`[1,1000]`到内存，用完后重新申请。
- 采用双Buffer机制异步更新号段，避免分配阻塞。

#### **优点**

- **高性能**：减少数据库访问频率（批量获取+内存分配）。
- **高可用**：DB宕机时，内存中剩余号段仍可支撑一段时间。
- **趋势递增**：适合MySQL索引优化。
- **无时钟依赖**：不受服务器时钟影响。

#### **缺点**

- **ID不连续**：号段用尽时可能跳号（如1000用完突然跳到2001）。
- **依赖DB**：数据库故障可能导致服务中断（需配合容灾方案）。
- **扩容复杂**：分库分表时需调整号段步长。

#### **适用场景**

- 高并发业务（如订单、支付系统）。
- 对递增性有要求但允许少量跳号的场景。
- 适合中小规模分布式系统（DB压力可控）。

### 2、Leaf-Snowflake

#### **原理**

- 基于Snowflake算法（64位：时间戳+WorkerID+序列号），改进点：
    - 通过ZooKeeper分配WorkerID，避免手动配置。
    - 解决时钟回拨问题（通过短暂等待或报错）。

#### **优点**

- **完全分布式**：无中心节点，依赖ZK管理WorkerID。
- **高性能**：本地生成ID，无网络开销。
- **时间有序**：ID严格递增，适合排序场景。
- **空间利用率高**：64位整数，存储成本低。

#### **缺点**

- **时钟敏感**：依赖NTP同步，时钟回拨可能导致服务不可用。
- **WorkerID限制**：WorkerID数量有限（通常10bit，最多1024个节点）。
- **数据倾斜**：低并发时可能浪费序列号。

#### **适用场景**

- 高并发且要求严格递增的场景（如消息队列、日志系统）。
- 无严格时钟回拨风险的云环境。
- 需要轻量级、无状态服务的场景（如微服务架构）。

### 3、Redis INCR + AOF + MQ

#### **原理**

- **Redis INCR**：利用原子操作生成连续ID。
- **AOF持久化**：确保宕机后ID不丢失。
- **MQ异步同步**：将生成的ID推送到消息队列供其他服务消费。

#### **优点**

- **超高并发**：Redis单机可达10万+/秒的吞吐量。
- **灵活性强**：可通过Lua脚本定制ID生成规则。
- **低延迟**：内存操作响应快。

#### **缺点**

- **持久化风险**：AOF刷盘策略影响性能和可靠性（`everysec`可能丢数据，`always`性能差）。
- **Redis单点问题**：需集群部署增加复杂度（Cluster模式可能影响INCR连续性）。
- **运维成本高**：需维护Redis和MQ的稳定性。

#### **适用场景**

- 需要极高并发且允许短暂不连续的场景（如秒杀、计数器）。
- 已深度依赖Redis的技术栈。
- 可接受最终一致性的业务（如活动ID、短链生成）。

### 用户ID和笔记ID生成场景的差异

#### 1、**用户 ID**

- **唯一性要求**：用户 ID 必须 **全局唯一**，并且在整个系统生命周期内保持不变。一个用户 ID 代表一个永久存在的用户。
- **生命周期**：用户的生命周期通常较长，一旦创建，ID 一般不会改变，甚至不允许重复。即便用户注销，ID 通常也不会被重用。
- **场景**：用户 ID 通常是用来标识一个长期存在的实体（如用户信息、订单、积分等），需要在数据库、外部系统和服务中长期使用。

#### 2、**笔记 ID**

- **唯一性要求**：笔记 ID 必须 **全局唯一**，每条笔记都需要一个唯一的 ID，但与用户 ID 不同，笔记 ID 的生命周期较短。
- **生命周期**：笔记 ID 只在笔记的生命周期内有效，一旦笔记删除，ID 可能会被回收（或者从数据库中删除）。
- **场景**：笔记 ID 代表的是一条短期存在的数据记录，它的生命周期由笔记本身决定，因此 ID 的生成方式可以更加灵活。

对于笔记 ID 生成场景，高并发下用户可能频繁发布笔记，瞬时峰值高（如热点事件）。这种情况下，**雪花算法**生成ID无需网络以及数据库IO 开销，性能远超号段模式，避免 DB 成为瓶颈，但需考虑时钟回拨问题。

时钟回拨问题解决方案：

- 美团方案：回拨超过阈值（如100ms）时触发报警，并自动切换为**号段模式**兜底。

对于用户 ID 生成场景，一般需要考虑的是长期稳定性，生成的 ID 必须在系统中长期有效，同时，一定程度上考虑高并发场景，比如某个时间段用户突然递增，比如前段时间，小红书外国用户大量涌入；以及内存占用问题。雪花算法占用64位且存在机器ID变化等问题，故不考虑，号段模式依赖数据库，不太适合高并发场景，故**最终选用 Redis INCR + AOF + MQ 方案**。

Redis INCR + AOF + MQ 方案**风险**：

- AOF 持久化可靠性，everysec 可能丢失1秒数据，可以在服务启动时检查 Redis 和 DB 的ID差值，自动补偿缺失ID
- MQ 异步写入延迟可能会造成 MQ 消息堆积，导致 DB 中 ID 不连续，可以同步+异步双写，同步写入本地文件（WAL日志），再通过 MQ 异步落库。

## 二、消息队列 RocketMQ

### 1、消息队列重复消费，幂等性如何保证？

>

### 2、消息队列的顺序性怎么保证？

>

### 3、